import numpy as np

# Features:
# x0 - (a) semi major axis
# x1 - (espilon) eccentricity
# x2 - (theta) orbital angle

X = np.random.randn(1000, 3)
y = (X[:, 0] * (1 - X[:, 1] * X[:, 1])) / (1 - (X[:, 1] * np.cos(X[:, 2])))

from pysr import PySRRegressor

model = PySRRegressor(
	binary_operators=['*', '-'],
	unary_operators=['cos', 'inv'],
	extra_sympy_mappings={'inv': lambda x: 1/x},
	niterations=10000000,
	populations=15,
	population_size=33,
	ncyclesperiteration=550,
	maxsize=20,
	maxdepth=None,
	constraints=None,
	nested_constraints=None,
	warmup_maxsize_by=0.0,
	should_simplify=None,
	max_evals=None,
	timeout_in_seconds=None,
	early_stop_condition="stop_if(loss, complexity) = loss < 1e-5 && complexity < 20",
	loss="loss(prediction, target) = (prediction - target)^2",
	full_objective=None,
	complexity_of_operators=None,
	complexity_of_constants=10,
	complexity_of_variables=1,
	parsimony=0.0032,
	dimensional_constraint_penalty=None,
	use_frequency=True,
	use_frequency_in_tournament=True,
	adaptive_parsimony_scaling=20.0,
	alpha=0.1,
	annealing=False,
	weight_add_node=2.5,
	weight_insert_node=5.1,
	weight_delete_node=3.0,
	weight_do_nothing=0.21,
	weight_mutate_constant=0.03,
	weight_mutate_operator=1.47,
	weight_randomize=0.004,
	weight_simplify=0.02,
	weight_optimize=0.0,
	crossover_probability=0.066,
	skip_mutation_failures=True,
	migration=True,
	hof_migration=True,
	fraction_replaced=0.000364,
	fraction_replaced_hof=0.035,
	topn=12,
	should_optimize_constants=True,
	optimizer_nrestarts=2,
	optimize_probability=0.14,
	optimizer_iterations=8,
	perturbation_factor=0.076,
	tournament_selection_n=10,
	tournament_selection_p=0.86,
	procs=16,
	multithreading=None,
	cluster_manager=None,
	batching=False,
	batch_size=50,
	fast_cycle=False,
	turbo=False,
	precision=32,
	enable_autodiff=False,
	random_state=None,
	deterministic=False,
	warm_start=False,
	verbosity=1,
	update_verbosity=None,
	print_precision=5,
	progress=True,
	equation_file=None,
	temp_equation_file=False,
	tempdir=None,
	delete_tempfiles=True,
	julia_project=None,
	update=False,
	output_jax_format=False,
	output_torch_format=False,
	extra_jax_mappings=None,
	extra_torch_mappings=None,
	denoise=False,
	select_k_features=None,
	julia_kwargs=None,
)

model.fit(X, y)
print(model)
